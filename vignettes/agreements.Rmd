---
title: "Agreements"
author: "James Hollway"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Outlining the problem

One of the central problems in ensembled data packages is 
setting equivalences between observations from different datasets.
This is a central problem because it is what enables us to _relate_ datasets
to one another.

What is required is some classificatory scheme so that same is recognised as same
and different observations are recognised as different.
In many cases, it is useful to have some kind of registry of unique units
that existing and, importantly, new data can be read against.

There are several important features of such a registry that,
while not _required_ are certainly very helpful:

1. **Authoritative**: the registry should be a singular source
1. **Comprehensivity**: the registry should ideally cover all possible units
1. **Succinct**: the registry codes should be as short as possible
1. **Intelligible**: the registry codes should be as meaningful for humans as possible

For some databases, unique identifiers are not too much of a problem because
there exists a relatively comprehensive, authoritative, succinct, and intelligible registry.
An example of this is the central `states` database in the `{qStates}` package.
Here we can rely on ISO-3166 alpha-3 codes for most modern states,
complementing them with COW or other codes for more historical states.
This combined registry is made available through the `qStates::code_states()` function.

But we are not aware of comprehensive, authoritative, succinct, and intelligible registry of treaties.
To solve this problem, we need to think both about how observations might be coded
and what this codes might represent.

## Setting up the problem

To test different solutions to the problem, 
we construct a sample of treaty titles from three different datasets in the `qEnviron::agreements` database.
Let's take only titles of treaties established in a particular decade, the 1980s, 
so that we can increase the probability of matches. 

```{r data, eval=FALSE}
library(qData)
samples <- lapply(qEnviron::agreements, function(x) x[x$Beg > "1980-01-01" & x$Beg < "1990-01-01", ])
titles <- unlist(purrr::map(samples, "Title"))
titles <- na.omit(titles)
titles <- standardise_titles(titles)
titles <- data.frame(titles)
dates <- lubridate::as_date(unlist(purrr::map(samples, "Beg")))
dates <- na.omit(lubridate::as_date(dates))
agreements <- data.frame(cbind(titles, dates))
agreements <- agreements[order(dates),]
agreements <- head(agreements, 200)
knitr::kable(agreements) %>%
  kableExtra::column_spec(1, width = "5em") %>% 
  kableExtra::column_spec(2, width = "40em")
```


```{r}
library(qData)
library(readr)
hand_coded_sample <- read_delim("hand-coded-sample.csv", ";", escape_double = FALSE, trim_ws = TRUE)
# hand_code_duplicates <- hand_coded_sample %>%  dplyr::select(duplicate) %>% 
#   dplyr::rename("hand_code_duplicates" = "duplicate")
# sum(hand_code_duplicates)
# agreements <- cbind(agreements, hand_code_duplicates)
agreements <- hand_coded_sample %>%
  dplyr::mutate(dates = standardise_dates(dates)) %>%
  dplyr::select(-c(X5,X7))
agreements
# knitr::kable(agreements, align = "lllcc") %>%
  # kableExtra::column_spec(1, width = "0em") %>% 
  # kableExtra::column_spec(2, width = "35em") %>% 
  # kableExtra::column_spec(3, width = "10em") %>% 
  # kableExtra::column_spec(4, width = "10em") %>% 
  # kableExtra::column_spec(5, width = "10em")
```

## Options for solutions

### Everything unique

First we could simply offer a unique code for each title.
Obviously this would generate errors on the side of false negatives 
for many titles that are quite obviously (for humans) equivalent.

### Strict match

Here we only consider equivalent those titles that are exactly the same as one another.

```{r}
# sum(duplicated(agreements$titles))
# knitr::kable(agreements, align = "llcc") %>%
  # kableExtra::column_spec(1, width = "6em") %>% 
  # kableExtra::column_spec(2, width = "30em") %>% 
  # kableExtra::column_spec(3, width = "6em") %>% 
  # kableExtra::column_spec(4, width = "10em")
```

Note that this is probably boosted by our use of `qData::standardise_titles()` in qPackages,
but misses a number of more problematic cases.
For example a "Treaty Of..." and "Treaty For..." would be considered distinct,
as would "Antarctic Treaty" and "Antarctic Treaty 1959",
even though they ought to be rendered equivalent.
Compare, for example, the number of duplicates found with strict match and with
manual coding of duplicates for the same sample.

### Fuzzy match

Fuzzy matching relies on `stringdist` to match observations.

  # a <- agreements
  # b <- agreements
  # 
  # out <- as.data.frame(fuzzyjoin::stringdist_inner_join(a, b, by = "titles", method = "lv", max_dist = 20, distance_col = "distance"))
  # The Levenshtein distance is set to 20 to accommodate matching between amendments and protocols to the same treaty. 
  # As well as to account for discrepancies in articles and other words.
  # Here we only select the titles that are matched below the maximum distance.
  
  # out <- out %>% dplyr::filter(distance > 0) %>% 
  #   dplyr::rename("titles" = "titles.x",
  #                 "fuzzy_match" = "titles.y") %>% 
  #   dplyr::select(titles, dates.x, fuzzy_match, dates.y, distance)
  # We exclude the ones which are a perfect match for now as we know there are 36 of these.
  
  # knitr::kable(out) %>%
  # kableExtra::column_spec(1, width = "30em") %>% 
  # kableExtra::column_spec(2, width = "8em") %>%
  # kableExtra::column_spec(3, width = "30em") %>% 
  # kableExtra::column_spec(4, width = "8em") %>%
  # kableExtra::column_spec(5, width = "8em") 
  # Fuzzy matching has found 46 variables that match at the set distance level. Though, are these really a match? 
  # As you can see from the table below, while most of the cases matched appear connected, some of the matching is indeed fuzzy.
  
  # c <- data.frame(out)
  # c$date <- lubridate::as_date(out$dates.x)
  # d <- as.data.frame(out)
  # d$date <- lubridate::as_date(out$dates.y)
  # e <- dplyr::inner_join(c, d)
  # summary(e)
  # We create two other sub-datasets with the date column of the fuzzy matches in each of the original datasets. 
  # We join them to see which fuzzy matches actually have the same dates, as these are very likely good matches.  
  # We find that out of the 46 fuzzy matches 30 are true positives while 16 could be considered false positives. 
  # While these are often protocols and agreements to the same treaty, it is hard to extract this information using fuzzy match. 
  # Moreover, there are considerable difficulties in setting a maximum distance that is not too small for fuzzy match to be helpful
  # and not too big that matches are not meaningful anymore.
```

There are some important advantages here, however:

1. is computationally expensive/takes a long time
1. errors on the side of false positives

### Identifying information extraction

Another option is to extract identifying information from the titles and dates,
rendering as equivalent any titles that have the same identifying information.

The key question here is which information to extract from the titles.
It needs to be enough information to render as distinct those titles that are indeed distinct,
but that ignores both less salient information (e.g. "Of" versus "For")
and addenda (e.g. the year at the end of the treaty title).

The less information we require for a match, the higher the false positive rate,
and the more information we require, the higher the false negative rate.

Using our current version of `{qData}` we obtain:

```{r}
agreements$qID <- qData::code_agreements(agreements$titles, agreements$dates)

# agreements$qID

  knitr::kable(agreements, align = "lccc") %>%
  kableExtra::column_spec(1, width = "5em") %>% 
  kableExtra::column_spec(2, width = "30em") %>% 
  kableExtra::column_spec(3, width = "10em")
```

Not only `code_agreements()` finds duplicates, but it also references to the type of treaty an observation is and to which other observation agreement is linked to. More details in how to read a qID are given below.

### Comparing specificity versus sensitivity

Since we hand coded the duplicates and know how many are actual duplicates and not, we can compare the specificity versus sensitivity for each of the 
possible solutions discussed above. 

```{r, eval=FALSE}
errortype <- data.frame(model = c("duplicates", "fuzzy_match", "code_agreements", "hand_code"),
                  true_pos = c(36, 66, 64, 130),
                  false_pos = c(0, 16, 0, 0),
                  false_neg = c(94, 48, 66, 0),
                  true_neg = c(70, 70, 70, 70)) %>% 
  dplyr::mutate(sensitivity = true_pos / (true_pos + false_neg),
				             specificity = 1 - (true_neg / (true_neg + false_pos)),
				             accuracy = (true_pos + true_neg)/200,
				             inaccuracy = 1 - ((true_pos + true_neg)/200))

# For fuzzy match the true positives score include the ones fuzzy matched (30) plus the exact duplicates (36).
# An illustrative comparison table ...
errortype

# Let's create an ROC plot for to illustrate better each model
error <- data.frame(hand_code = 1:200, duplicates = 1:200, fuzzy_match = 1:200, code_agreements = 1:200)
error <- error %>% dplyr::mutate(hand_code = ifelse(error$hand_code < 131, 1, 0), 
                                 duplicates = ifelse(error$duplicates < 37, 1, 0),
                                 fuzzy_match = ifelse(error$fuzzy_match > 130 & error$fuzzy_match < 147, 1, fuzzy_match),
                                 fuzzy_match = ifelse(error$fuzzy_match < 67, 1, fuzzy_match),
                                 fuzzy_match = ifelse(error$fuzzy_match > 146, 0, fuzzy_match),
                                 fuzzy_match = ifelse(error$fuzzy_match > 66 & error$fuzzy_match < 131, 0, fuzzy_match),
                                 code_agreements = ifelse(error$code_agreements < 65, 1, 0)) 
error <- error[sample(nrow(error)),]
row.names(error) <- NULL
# Shuffling things around to avoid unwarranted correlations

strict <- glm(hand_code ~ duplicates, data = error) 
fuzzy <- glm(hand_code ~ fuzzy_match, data = error)
code <- glm(hand_code ~ code_agreements, data = error) 

library(ROCR)

strict_plot <- predict(strict, error, type = 'response')
strict_plot <- prediction(strict_plot, error$hand_code)
eval_strict <- performance(strict_plot, "sens", "spec")
plot(eval_strict)

fuzzy_plot <- predict(fuzzy, error, type = 'response')
fuzzy_plot <- prediction(fuzzy_plot, error$hand_code)
eval_fuzzy <- performance(fuzzy_plot, "sens", "spec")
plot(eval_fuzzy)

code_plot <- predict(code, error, type = 'response')
code_plot <- prediction(code_plot, error$hand_code)
eval_code <- performance(code_plot, "sens", "spec")
plot(eval_code)

plot(NULL,xlim=c(0,1),ylim=c(0,1),
xlab="Sensitivity",ylab="Specificity")
lines(eval_strict@x.values[[1]],eval_strict@y.values[[1]])
lines(eval_fuzzy@x.values[[1]],eval_fuzzy@y.values[[1]])
lines(eval_code@x.values[[1]],eval_code@y.values[[1]])
# Lines 249-253 above must be run altogether otherwise error is produced 

# Another option
library(pROC)

roc1 = roc(hand_code ~ duplicates, data = error)
roc2 = roc(hand_code ~ fuzzy_match, data = error)
roc3 = roc(hand_code ~ code_agreements, data = error)

plot(roc1, col = 1, lty = 2, main = "ROC")
plot(roc2, col = 3, lty = 3, add = TRUE)
plot(roc3, col = 6, lty = 3, add = TRUE)
# Lines 263-255 above must be run altogether otherwise error is produced 
# tofix: need to add subtitles and make it pretty still...

```

## How to read a qID

A qID is a meaningful shorthand ID created from a combination of elements extracted from the agreement title and date. The qID allows users to identify 
bilateral treaties, date, type and linkage. 

**Type** | **Pasting** | **Pasting**
--- | --- |--- 
Bilateral | 19060521A_MEX-USA | uID, type_parties
Bilateral + Protocol | 18840921E3_18840921_BAD-CHE | uID,type(number)_linkage_parties

A bilateral treaty that is an agreement will have the following qID: "19060521A_MEX-USA". This is a combination of the date (19060521) 
with the type(A) and the parties to agreement (MEX-USA). A bilateral treaty that is any other type than an agreement (e.g. protocol, amendments) will have 
the qID under this format: "18840921E3_BAD-CHE_18830703". The date of signature of the amendment (18840921), the type (E) which refers 
to amendment, the number of amendment (3), the parties (BAD-CHE) and finally the signature date of the "mother" treaty (18830703).

**Type** | **Pasting** | **Pasting**
--- | --- |--- 
Multilateral | 20050205A | uID, type
Multilateral + Protocol | 19920817E2_20070817 | uID,type(number)_linkage

A multilateral treaty that is an agreement will have the following qID: "20050205A" which indicates the signature date of the agreement 
(20050205) and the type (A). A multilateral treaty that is not an agreement will have this qID format: "19920817E2_20070817". This represents the signature date of the amendment (19920817), the type (E), the number of amendment (2) and the linkage number (20070817) which is the signature 
date of the "mother" treaty. 

**Type** | **Pasting** | **Pasting**
--- | --- |--- 
Known treaties | 	UNCLOS_19821210 | abbreviation_uID
Amendment of known treaties | MARPOL_19731102_19900316E | abbreviation_linkage_uID,type(number)

Famous multilateral treaties have a simplified qID with an known abbreviation. For example, the United Nations Convention On The Law Of
The Sea will have the following qID: "UNCLOC_19821210A" which is the known abbreviation (UNCLOS), the signature date (19821210) with the type (A). The 
protocols or amendments of the known treaties will have this qID format: "MARPOL_19890317E2_19731102". It indicates the known abbreviation (MARPOL), the signature date of this specific amendment (19890317), the type of treaty (E), its number (2) and the signature date of the "mother" treaty (19731102).

## How `code_agreements()` work

The function extracts important information from treaty titles and dates each step if the way to make sure duplicates are actual duplicates as well as
to identify linkages between treaties.   

### Parties

The first element extracted from the title is the state that is part to the treaty. The function `code_states()` from `qStates` is used. It returns 3 digit 
ISO codes for states.

```{r, eval=FALSE}
qData::code_parties(titles)
```

### Date

Each treaty contains a unique number in their qID which refer to the signature date. The number has therefore eight numbers that are under the YYYYMMDD 
format. 

```{r, eval=FALSE}
qData::code_dates(dates)
```

### Type

The function detects the type of treaty and assign a letter that will be included in the final ID. 

```{r, eval=FALSE}
qData::code_type(titles)
```

* Agreements = **A**
* Amendments = **E**
* Protocol = **P**
* Exchange of Notes = **X**
* Memorandum of Understanding = **Y**
* Strategy = **S**

For amendments or protocol, their ordering number is also extracted from the title to be included in the qID. 

### Linkage

Detects the family a treaty might belong to. Treaties from the same family can be detected by removing predictable words that are added to treaty titles 
(e.g. amendment, protocol, meeting) and identifying duplicates based on the core words used to refer to main agreement. The YYYYMMDD number assigned to the 
"mother" treaty is used for all the other treaties deriving from it as the last digits in their qID.

```{r, eval=FALSE}
qData::code_linkage(titles, dates)
```

### Known Agreements

Are these a famous agreements for which abbreviations are known? Some treaties already have known abbreviation. The qID of these treaties contain their abbreviation.

```{r, eval=FALSE}
qData::code_known_agreements(titles)
```

**Example**

**Know Agreements** | **Abbreviation**
--- | ---
"United Nations Convention On The Law Of The Sea" | UNCLOS
"Convention On Biological Diversity" | CBD
"Convention On The Conservation Of Antarctic Marine Living Resources" | CCAMLR
"Convention On International Trade In Endangered Species Of Wild Fauna And Flora" | CITES
"International Convention On Civil Liability For Oil Pollution Damage" | CLC
"Antarctic Mineral Resources Convention" | CRAMRA
"Convention On The Protection And Use Of Transboundary Watercourses And International Lakes" | CECE
"Convention On Long-Range Transboundary Air Pollution" | LRTAP
"International Convention For The Prevention Of Pollution From Ships" | MARPOL
"North American Agreement On Environmental Cooperation" | NAAEC
"Constitutional Agreement Of The Latin American Organization For Fisheries Development" | OLDEPESCA
"International Convention On Oil Pollution Preparedness, Response And Cooperation" | OPRC
"Convention For The Protection Of The Marine Environment Of The North East Atlantic" | OSPAR
"Paris Agreement Under The United Nations Framework Convention On Climate Change" | PARIS
"Convention On The Prior Informed Consent Procedure For Certain Hazardous Chemicals And Pesticides In International Trade" | PIC
"Convention On Wetlands Of International Importance Especially As Waterfowl Habitat" | RAMSA
"Convention To Combat Desertification In Those Countries Experiencing Serious Drought And/Or Desertification, Particularly In Africa" | UNCCD
"United Nations Framework Convention On Climate Change" | UNFCCC
"Convention For The Protection Of The Ozone Layer" | VIENNA

Once added together the information extracted from treaty title and date forms a qID which is more authoritative, comprehensible, succinct and intelligible 
than other naming conventions.
